<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <title>Home Movie Maker</title>
  <meta name="description" content="Professional home video editing with vintage filters">
  <meta name="theme-color" content="#0d0d0d">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Movie Maker">
  
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230d0d0d' width='100' height='100' rx='15'/><polygon points='35,25 35,75 75,50' fill='%234a9eff'/></svg>">
  
  <link href="https://fonts.googleapis.com/css2?family=VT323&family=Inter:wght@400;500;600&family=Press+Start+2P&family=Share+Tech+Mono&display=swap" rel="stylesheet">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js" crossorigin="anonymous"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg-darkest: #0a0a0a;
      --bg-dark: #111;
      --bg-panel: #1a1a1a;
      --bg-elevated: #222;
      --bg-hover: #2a2a2a;
      --border: #333;
      --text: #e0e0e0;
      --text-dim: #888;
      --text-muted: #555;
      --accent: #4a9eff;
      --accent-hover: #6bb3ff;
      --accent-dim: rgba(74, 158, 255, 0.15);
      --success: #4ade80;
      --danger: #ef4444;
    }
    
    html, body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-darkest);
      color: var(--text);
      min-height: 100vh;
      min-height: 100dvh;
      overflow-x: hidden;
      font-size: 14px;
    }
    
    /* Login Screen */
    .login-screen {
      position: fixed;
      inset: 0;
      background: var(--bg-darkest);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    
    .login-screen.hidden { display: none; }
    
    .login-box {
      text-align: center;
      padding: 40px;
    }
    
    .login-box h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .login-box p {
      color: var(--text-dim);
      margin-bottom: 32px;
      font-size: 14px;
    }
    
    .login-input {
      width: 280px;
      padding: 14px 20px;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 16px;
      text-align: center;
      margin-bottom: 16px;
      display: block;
    }
    
    .login-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .login-input.error {
      border-color: var(--danger);
      animation: shake 0.4s;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }
    
    .login-btn {
      width: 280px;
      padding: 14px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 15px;
      font-weight: 500;
      cursor: pointer;
    }
    
    .login-btn:hover { background: var(--accent-hover); }
    
    .login-error {
      color: var(--danger);
      font-size: 13px;
      margin-top: 12px;
      height: 20px;
    }
    
    /* App Layout */
    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
    }
    
    /* Top Bar */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 48px;
      padding: 0 16px;
      background: var(--bg-dark);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    
    .topbar-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      font-size: 15px;
    }
    
    .logo svg {
      width: 24px;
      height: 24px;
    }
    
    .menu-btns {
      display: flex;
      gap: 4px;
    }
    
    .menu-btn {
      padding: 6px 12px;
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 13px;
      cursor: pointer;
      border-radius: 4px;
    }
    
    .menu-btn:hover {
      background: var(--bg-hover);
      color: var(--text);
    }
    
    .topbar-right {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .project-name {
      font-size: 13px;
      color: var(--text-dim);
      padding: 4px 10px;
      background: var(--bg-panel);
      border-radius: 4px;
    }
    
    .save-indicator {
      font-size: 11px;
      color: var(--text-muted);
    }
    
    .save-indicator.saved { color: var(--success); }
    
    .clip-count {
      font-size: 12px;
      color: var(--text-dim);
      padding: 4px 10px;
      background: var(--bg-panel);
      border-radius: 4px;
    }
    
    /* Main Area */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    /* Left Panel */
    .panel-left {
      width: 280px;
      background: var(--bg-panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }
    
    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: var(--bg-elevated);
      border-bottom: 1px solid var(--border);
    }
    
    .panel-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
    }
    
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    
    /* Import Buttons */
    .import-btns {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .import-btn {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-elevated);
      border: 1px dashed var(--border);
      border-radius: 6px;
      color: var(--text-dim);
      font-size: 13px;
      cursor: pointer;
    }
    
    .import-btn:hover {
      border-color: var(--accent);
      color: var(--text);
      background: var(--accent-dim);
    }
    
    .import-btn input { display: none; }
    
    /* Media List */
    .media-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .media-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      background: var(--bg-elevated);
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .media-item:hover { background: var(--bg-hover); }
    .media-item.selected { border-color: var(--accent); background: var(--accent-dim); }
    
    .media-thumb {
      width: 48px;
      height: 32px;
      background: var(--bg-dark);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .media-info { flex: 1; min-width: 0; }
    
    .media-name {
      font-size: 12px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .media-meta {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    
    .media-delete {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px;
      opacity: 0;
    }
    
    .media-item:hover .media-delete { opacity: 1; }
    .media-delete:hover { color: var(--danger); }
    
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
    }
    
    .empty-state svg {
      width: 48px;
      height: 48px;
      margin-bottom: 12px;
      opacity: 0.3;
    }
    
    /* Center - Preview */
    .panel-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-dark);
      min-width: 0;
    }
    
    .preview-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      position: relative;
    }
    
    #previewCanvas {
      max-width: 100%;
      max-height: 100%;
    }
    
    #videoElement { display: none; }
    
    .no-preview {
      text-align: center;
      color: var(--text-muted);
    }
    
    .no-preview svg {
      width: 64px;
      height: 64px;
      margin-bottom: 16px;
      opacity: 0.2;
    }
    
    /* Controls */
    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
    }
    
    .transport {
      display: flex;
      gap: 4px;
    }
    
    .transport-btn {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-elevated);
      border: none;
      border-radius: 6px;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
    }
    
    .transport-btn:hover { background: var(--bg-hover); }
    .transport-btn.play { background: var(--accent); color: #fff; }
    .transport-btn.play:hover { background: var(--accent-hover); }
    
    .time-display {
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
      color: var(--text-dim);
      min-width: 90px;
    }
    
    .scrubber {
      flex: 1;
      height: 6px;
      background: var(--bg-elevated);
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }
    
    .scrubber-fill {
      height: 100%;
      background: var(--accent);
      border-radius: 3px;
      width: 0%;
      pointer-events: none;
    }
    
    /* Right Panel */
    .panel-right {
      width: 300px;
      background: var(--bg-panel);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      overflow-y: auto;
    }
    
    .section {
      border-bottom: 1px solid var(--border);
    }
    
    .section-header {
      padding: 12px 16px;
      background: var(--bg-elevated);
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
    }
    
    .section-body {
      padding: 16px;
    }
    
    .form-row {
      margin-bottom: 14px;
    }
    
    .form-row:last-child { margin-bottom: 0; }
    
    .form-label {
      display: block;
      font-size: 12px;
      color: var(--text-dim);
      margin-bottom: 6px;
    }
    
    .form-input {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
    }
    
    .form-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .form-select {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 13px;
    }
    
    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .slider-input {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: var(--bg-dark);
      border-radius: 2px;
    }
    
    .slider-input::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
    }
    
    .slider-value {
      font-size: 12px;
      color: var(--text-dim);
      min-width: 35px;
      text-align: right;
    }
    
    /* Filter Grid */
    .filter-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    
    .filter-btn {
      padding: 8px 4px;
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-dim);
      font-size: 10px;
      cursor: pointer;
      text-align: center;
    }
    
    .filter-btn:hover { background: var(--bg-hover); color: var(--text); }
    .filter-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
    
    /* Toggle */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
    }
    
    .toggle {
      width: 36px;
      height: 20px;
      background: var(--bg-dark);
      border-radius: 10px;
      cursor: pointer;
      position: relative;
    }
    
    .toggle.on { background: var(--accent); }
    
    .toggle::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    
    .toggle.on::after { transform: translateX(16px); }
    
    /* Color Options */
    .color-options {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .color-btn {
      width: 28px;
      height: 28px;
      border: 2px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 9px;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .color-btn:hover { border-color: var(--text-dim); }
    .color-btn.active { border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-dim); }
    
    .color-btn[data-color="auto"] {
      background: linear-gradient(135deg, #333 50%, #fff 50%);
      font-size: 8px;
      font-weight: 600;
    }
    
    /* Action Buttons */
    .action-btns {
      display: flex;
      gap: 8px;
      padding: 16px;
    }
    
    .action-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .action-btn.primary { background: var(--accent); color: #fff; }
    .action-btn.primary:hover { background: var(--accent-hover); }
    .action-btn.secondary { background: var(--bg-elevated); color: var(--text); border: 1px solid var(--border); }
    .action-btn.secondary:hover { background: var(--bg-hover); }
    
    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9000;
      padding: 20px;
    }
    
    .modal-overlay.active { display: flex; }
    
    .modal {
      background: var(--bg-panel);
      border-radius: 12px;
      width: 100%;
      max-width: 400px;
      border: 1px solid var(--border);
    }
    
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .modal-header h3 { font-size: 16px; font-weight: 600; }
    
    .modal-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 20px;
      cursor: pointer;
    }
    
    .modal-body { padding: 20px; }
    
    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }
    
    .export-option {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 16px;
      background: var(--bg-elevated);
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .export-option:hover { border-color: var(--accent); background: var(--accent-dim); }
    .export-option:last-child { margin-bottom: 0; }
    
    .export-icon { font-size: 24px; }
    .export-title { font-size: 14px; font-weight: 500; }
    .export-desc { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
    
    /* Drive Modal */
    .drive-modal {
      background: var(--bg-panel);
      border-radius: 12px;
      width: 95%;
      max-width: 700px;
      height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
    }
    
    .drive-breadcrumb {
      display: flex;
      gap: 4px;
      padding: 12px 20px;
      background: var(--bg-dark);
      overflow-x: auto;
      flex-shrink: 0;
    }
    
    .breadcrumb-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 13px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .breadcrumb-btn:hover { background: var(--bg-hover); }
    .breadcrumb-btn.current { color: var(--text); cursor: default; }
    .breadcrumb-sep { color: var(--text-muted); }
    
    .drive-grid {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 12px;
      align-content: start;
    }
    
    .drive-folder, .drive-video {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.15s;
    }
    
    .drive-folder {
      background: var(--bg-elevated);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .drive-folder:hover { background: var(--bg-hover); border-color: var(--border); }
    .drive-folder .icon { font-size: 2.5rem; }
    .drive-folder .name { font-size: 11px; text-align: center; padding: 0 8px; }
    
    .drive-video {
      background: var(--bg-dark);
      position: relative;
      overflow: hidden;
    }
    
    .drive-video:hover { border-color: var(--accent); }
    .drive-video.selected { border-color: var(--accent); background: var(--accent-dim); }
    
    .drive-video img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .drive-video .placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }
    
    .drive-video .check {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: var(--accent);
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
    }
    
    .drive-video.selected .check { display: flex; }
    
    .drive-video .info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      font-size: 10px;
    }
    
    .drive-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 60px;
      color: var(--text-muted);
    }
    
    .drive-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 12px;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Processing Overlay */
    .processing {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    
    .processing.active { display: flex; }
    
    .processing .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .processing .text {
      margin-top: 20px;
      color: var(--text-dim);
    }
    
    .processing .percent {
      margin-top: 8px;
      font-size: 24px;
      font-weight: 600;
    }
    
    /* Mobile */
    @media (max-width: 1024px) {
      .panel-left, .panel-right { display: none; }
      .menu-btns { display: none; }
    }
    
    @media (max-width: 768px) {
      .topbar { padding: 0 12px; }
      .logo span { display: none; }
      
      .mobile-tabs {
        display: flex;
        background: var(--bg-panel);
        border-top: 1px solid var(--border);
      }
      
      .mobile-tab {
        flex: 1;
        padding: 12px;
        background: none;
        border: none;
        color: var(--text-dim);
        font-size: 11px;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }
      
      .mobile-tab.active { color: var(--accent); }
      
      .panel-left.mobile-show,
      .panel-right.mobile-show {
        display: flex;
        position: fixed;
        top: 48px;
        bottom: 56px;
        width: 100%;
        max-width: none;
        z-index: 100;
      }
    }
    
    @media (min-width: 769px) {
      .mobile-tabs { display: none; }
    }
    
    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-dark); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
  </style>
</head>
<body>
  <!-- Login Screen -->
  <div class="login-screen" id="loginScreen">
    <div class="login-box">
      <h1>Home Movie Maker</h1>
      <p>Enter password to continue</p>
      <form onsubmit="return checkPassword(event)">
        <input type="password" class="login-input" id="passwordInput" placeholder="Password" autocomplete="current-password">
        <button type="submit" class="login-btn">Sign In</button>
      </form>
      <div class="login-error" id="loginError"></div>
    </div>
  </div>

  <!-- Main App -->
  <div class="app">
    <!-- Top Bar -->
    <div class="topbar">
      <div class="topbar-left">
        <div class="logo">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polygon points="5,3 19,12 5,21" fill="var(--accent)"/>
          </svg>
          <span>Home Movie Maker</span>
        </div>
        <div class="menu-btns">
          <button class="menu-btn" onclick="document.getElementById('fileInput').click()">Import</button>
          <button class="menu-btn" onclick="openDrivePicker()">Google Drive</button>
        </div>
      </div>
      <div class="topbar-right">
        <span class="clip-count" id="clipCount"></span>
      </div>
    </div>
    
    <!-- Main Area -->
    <div class="main">
      <!-- Left Panel - Media -->
      <div class="panel-left" id="panelLeft">
        <div class="panel-header">
          <span class="panel-title">Media</span>
        </div>
        <div class="panel-content">
          <div class="import-btns">
            <label class="import-btn">
              <span>üìÅ</span>
              <span>Import Files</span>
              <input type="file" id="fileInput" accept="video/*" multiple onchange="handleFileSelect(event)">
            </label>
            <button class="import-btn" id="driveBtn" onclick="openDrivePicker()">
              <span>‚òÅÔ∏è</span>
              <span>Google Drive</span>
            </button>
          </div>
          <div class="media-list" id="mediaList">
            <div class="empty-state">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="2" y="2" width="20" height="20" rx="2"/>
                <path d="M10 8l6 4-6 4V8z"/>
              </svg>
              <p>Import videos to start</p>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Center - Preview -->
      <div class="panel-center" id="panelCenter">
        <div class="preview-area">
          <video id="videoElement" crossorigin="anonymous" playsinline></video>
          <canvas id="previewCanvas"></canvas>
          <div class="no-preview" id="noPreview">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
              <rect x="2" y="2" width="20" height="20" rx="2"/>
              <path d="M10 8l6 4-6 4V8z"/>
            </svg>
            <p>Select a clip to preview</p>
          </div>
        </div>
        <div class="controls">
          <div class="transport">
            <button class="transport-btn" onclick="skipBackward()">‚è™</button>
            <button class="transport-btn play" id="playBtn" onclick="togglePlay()">‚ñ∂</button>
            <button class="transport-btn" onclick="skipForward()">‚è©</button>
          </div>
          <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
          <div class="scrubber" id="scrubber" onclick="seek(event)">
            <div class="scrubber-fill" id="scrubberFill"></div>
          </div>
        </div>
      </div>
      
      <!-- Right Panel - Properties -->
      <div class="panel-right" id="panelRight">
        <div class="section">
          <div class="section-header">Clip Info</div>
          <div class="section-body">
            <div class="form-row">
              <label class="form-label">Title Overlay</label>
              <input type="text" class="form-input" id="titleInput" placeholder="Enter title..." oninput="updateTitle(this.value)">
            </div>
            <div class="form-row">
              <label class="form-label">Override Date</label>
              <input type="date" class="form-input" id="dateInput" onchange="updateDate(this.value)">
            </div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-header">Text Style</div>
          <div class="section-body">
            <div class="form-row">
              <label class="form-label">Font</label>
              <select class="form-select" id="fontSelect" onchange="updateFont(this.value)">
                <optgroup label="Retro">
                  <option value="VT323" selected>VT323 (VHS Classic)</option>
                  <option value="Press Start 2P">Press Start 2P</option>
                  <option value="Share Tech Mono">Share Tech Mono</option>
                  <option value="Courier New">Courier New</option>
                </optgroup>
                <optgroup label="Modern">
                  <option value="Inter">Inter</option>
                  <option value="Arial">Arial</option>
                  <option value="Helvetica">Helvetica</option>
                  <option value="system-ui">System Default</option>
                </optgroup>
                <optgroup label="Elegant">
                  <option value="Georgia">Georgia</option>
                  <option value="Times New Roman">Times New Roman</option>
                  <option value="Palatino">Palatino</option>
                </optgroup>
              </select>
            </div>
            <div class="form-row">
              <label class="form-label">Font Size</label>
              <div class="slider-row">
                <input type="range" class="slider-input" id="fontSizeSlider" min="12" max="100" value="24" oninput="updateFontSize(this.value)">
                <span class="slider-value" id="fontSizeValue">24px</span>
              </div>
            </div>
            <div class="form-row">
              <label class="form-label">Text Color</label>
              <div class="color-options" id="colorOptions">
                <button class="color-btn active" data-color="auto" onclick="setTextColor('auto')" title="Auto (adapts to video)">Auto</button>
                <button class="color-btn" data-color="#feca57" onclick="setTextColor('#feca57')" style="background:#feca57" title="Yellow"></button>
                <button class="color-btn" data-color="#ffffff" onclick="setTextColor('#ffffff')" style="background:#ffffff" title="White"></button>
                <button class="color-btn" data-color="#ff6b6b" onclick="setTextColor('#ff6b6b')" style="background:#ff6b6b" title="Red"></button>
                <button class="color-btn" data-color="#48dbfb" onclick="setTextColor('#48dbfb')" style="background:#48dbfb" title="Cyan"></button>
                <button class="color-btn" data-color="#2ed573" onclick="setTextColor('#2ed573')" style="background:#2ed573" title="Green"></button>
              </div>
            </div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-header">Filter</div>
          <div class="section-body">
            <div class="filter-grid" id="filterGrid">
              <button class="filter-btn active" data-filter="none" onclick="setFilter('none')">None</button>
              <button class="filter-btn" data-filter="vhs" onclick="setFilter('vhs')">VHS</button>
              <button class="filter-btn" data-filter="super8" onclick="setFilter('super8')">Super 8</button>
              <button class="filter-btn" data-filter="8mm" onclick="setFilter('8mm')">8mm</button>
              <button class="filter-btn" data-filter="16mm" onclick="setFilter('16mm')">16mm</button>
              <button class="filter-btn" data-filter="cinematic" onclick="setFilter('cinematic')">Cinema</button>
              <button class="filter-btn" data-filter="noir" onclick="setFilter('noir')">Noir</button>
              <button class="filter-btn" data-filter="betamax" onclick="setFilter('betamax')">Betamax</button>
              <button class="filter-btn" data-filter="surveillance" onclick="setFilter('surveillance')">Security</button>
            </div>
            <div class="form-row" style="margin-top: 14px;">
              <label class="form-label">Intensity</label>
              <div class="slider-row">
                <input type="range" class="slider-input" id="intensitySlider" min="0" max="100" value="70" oninput="updateIntensity(this.value)">
                <span class="slider-value" id="intensityValue">70%</span>
              </div>
            </div>
          </div>
        </div>
        
        <div class="section">
          <div class="section-header">Overlays</div>
          <div class="section-body">
            <div class="toggle-row">
              <span class="form-label">Timestamp</span>
              <div class="toggle on" id="toggleTimestamp" onclick="toggleOverlay('timestamp')"></div>
            </div>
            <div class="toggle-row">
              <span class="form-label">Camera Info</span>
              <div class="toggle" id="toggleCamera" onclick="toggleOverlay('camera')"></div>
            </div>
            <div class="toggle-row">
              <span class="form-label">Location</span>
              <div class="toggle" id="toggleLocation" onclick="toggleOverlay('location')"></div>
            </div>
          </div>
        </div>
        
        <div class="action-btns">
          <button class="action-btn primary" onclick="downloadCurrentClip()">üíæ Download Clip (MP4)</button>
        </div>
        <div class="action-btns">
          <button class="action-btn secondary" onclick="downloadAllClips()">üìπ Download All (MP4)</button>
        </div>
        <p style="font-size: 10px; color: var(--text-muted); text-align: center; padding: 0 16px;">First download loads encoder (~25MB)</p>
      </div>
    </div>
    
    <!-- Mobile Tabs -->
    <div class="mobile-tabs">
      <button class="mobile-tab active" onclick="showMobilePanel('left')">üìÅ Media</button>
      <button class="mobile-tab" onclick="showMobilePanel('center')">‚ñ∂Ô∏è Preview</button>
      <button class="mobile-tab" onclick="showMobilePanel('right')">‚öôÔ∏è Settings</button>
    </div>
  </div>
  
  <!-- Drive Modal -->
  <div class="modal-overlay" id="driveModal">
    <div class="drive-modal">
      <div class="modal-header">
        <h3>Google Drive</h3>
        <button class="modal-close" onclick="closeDriveModal()">√ó</button>
      </div>
      <div class="drive-breadcrumb" id="driveBreadcrumb">
        <button class="breadcrumb-btn current">My Drive</button>
      </div>
      <div class="drive-loading" id="driveLoading">
        <div class="spinner"></div>
        <p>Loading...</p>
      </div>
      <div class="drive-grid" id="driveGrid"></div>
      <div class="modal-footer">
        <button class="action-btn secondary" onclick="closeDriveModal()">Cancel</button>
        <button class="action-btn primary" id="driveImportBtn" disabled onclick="importSelected()">Import</button>
      </div>
    </div>
  </div>
  
  <!-- Processing Overlay -->
  <div class="processing" id="processing">
    <div class="spinner"></div>
    <div class="text" id="processingText">Processing...</div>
    <div class="percent" id="processingPercent">0%</div>
  </div>

  <script>
    // ========== PASSWORD ==========
    const CORRECT = [51,36,116,104,51,114,64,50,48,48,49,48,116,104,83,84,33];
    
    function checkPassword(e) {
      e.preventDefault();
      const input = document.getElementById('passwordInput');
      const entered = input.value;
      const correct = CORRECT.map(c => String.fromCharCode(c)).join('');
      
      if (entered === correct) {
        sessionStorage.setItem('hmm_auth', 'true');
        document.getElementById('loginScreen').classList.add('hidden');
      } else {
        document.getElementById('loginError').textContent = 'Incorrect password';
        input.classList.add('error');
        input.value = '';
        setTimeout(() => input.classList.remove('error'), 400);
      }
      return false;
    }
    
    if (sessionStorage.getItem('hmm_auth') === 'true') {
      document.getElementById('loginScreen').classList.add('hidden');
    }
    
    // ========== STATE ==========
    let videos = [];
    let selectedVideo = null;
    let isPlaying = false;
    let currentFilter = 'none';
    let filterIntensity = 0.7;
    let showTimestamp = true;
    let showCameraInfo = false;
    let showLocation = false;
    
    // Text style settings
    let currentFont = 'VT323';
    let currentFontSize = 24;
    let currentTextColor = 'auto';
    
    const videoElement = document.getElementById('videoElement');
    const previewCanvas = document.getElementById('previewCanvas');
    const ctx = previewCanvas.getContext('2d');
    
    // ========== FILE HANDLING ==========
    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      files.forEach(file => addVideo(file));
      e.target.value = '';
    }
    
    async function addVideo(file, meta = {}) {
      const extractedMeta = await extractVideoMetadata(file);
      
      const video = {
        id: Date.now() + Math.random(),
        file,
        name: file.name,
        url: URL.createObjectURL(file),
        uploadTime: new Date(),
        recordingDate: meta.recordingDate || extractedMeta.creationDate,
        title: meta.title || '',
        filter: meta.filter || 'none',
        filterIntensity: meta.filterIntensity || 0.7,
        customDate: meta.customDate || '',
        fontFamily: meta.fontFamily || 'VT323',
        fontSize: meta.fontSize || 24,
        textColor: meta.textColor || 'auto',
        metadata: {
          camera: meta.camera || extractedMeta.camera || '',
          location: meta.location || extractedMeta.location || '',
          gps: extractedMeta.gps,
          source: meta.source || 'Local'
        }
      };
      
      videos.push(video);
      videos.sort((a, b) => (a.recordingDate || a.uploadTime) - (b.recordingDate || b.uploadTime));
      renderMediaList();
      selectVideo(video.id);
      
    }
    
    function renderMediaList() {
      const list = document.getElementById('mediaList');
      const countEl = document.getElementById('clipCount');
      
      // Update clip count
      countEl.textContent = videos.length > 0 ? `${videos.length} clip${videos.length !== 1 ? 's' : ''}` : '';
      
      if (videos.length === 0) {
        list.innerHTML = `
          <div class="empty-state">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <rect x="2" y="2" width="20" height="20" rx="2"/>
              <path d="M10 8l6 4-6 4V8z"/>
            </svg>
            <p>Import videos to start</p>
          </div>
        `;
        return;
      }
      
      list.innerHTML = videos.map(v => {
        const date = v.recordingDate || v.uploadTime;
        return `
          <div class="media-item ${selectedVideo?.id === v.id ? 'selected' : ''}" onclick="selectVideo('${v.id}')">
            <div class="media-thumb">üé¨</div>
            <div class="media-info">
              <div class="media-name">${v.name}</div>
              <div class="media-meta">${date.toLocaleDateString()} ${v.filter !== 'none' ? '‚Ä¢ ' + v.filter : ''}</div>
            </div>
            <button class="media-delete" onclick="event.stopPropagation(); deleteVideo('${v.id}')">üóëÔ∏è</button>
          </div>
        `;
      }).join('');
    }
    
    function selectVideo(id) {
      selectedVideo = videos.find(v => v.id == id);
      if (!selectedVideo) return;
      
      renderMediaList();
      document.getElementById('noPreview').style.display = 'none';
      previewCanvas.style.display = 'block';
      
      videoElement.src = selectedVideo.url;
      videoElement.onloadeddata = () => {
        previewCanvas.width = videoElement.videoWidth;
        previewCanvas.height = videoElement.videoHeight;
        drawFrame();
      };
      
      // Update UI
      document.getElementById('titleInput').value = selectedVideo.title || '';
      document.getElementById('dateInput').value = selectedVideo.customDate || '';
      setFilter(selectedVideo.filter, false);
      document.getElementById('intensitySlider').value = selectedVideo.filterIntensity * 100;
      document.getElementById('intensityValue').textContent = Math.round(selectedVideo.filterIntensity * 100) + '%';
      filterIntensity = selectedVideo.filterIntensity;
      
      // Load font settings
      currentFont = selectedVideo.fontFamily || 'VT323';
      currentFontSize = selectedVideo.fontSize || 24;
      currentTextColor = selectedVideo.textColor || 'auto';
      
      document.getElementById('fontSelect').value = currentFont;
      document.getElementById('fontSizeSlider').value = currentFontSize;
      document.getElementById('fontSizeValue').textContent = currentFontSize + 'px';
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === currentTextColor);
      });
    }
    
    function deleteVideo(id) {
      videos = videos.filter(v => v.id != id);
      if (selectedVideo?.id == id) {
        selectedVideo = null;
        document.getElementById('noPreview').style.display = 'flex';
        previewCanvas.style.display = 'none';
      }
      renderMediaList();
      
    }
    
    // ========== PLAYBACK ==========
    function togglePlay() {
      if (!selectedVideo) return;
      
      if (isPlaying) {
        videoElement.pause();
        isPlaying = false;
        document.getElementById('playBtn').textContent = '‚ñ∂';
      } else {
        videoElement.play();
        isPlaying = true;
        document.getElementById('playBtn').textContent = '‚è∏';
        animate();
      }
    }
    
    function animate() {
      if (!isPlaying) return;
      drawFrame();
      updateTimeDisplay();
      requestAnimationFrame(animate);
    }
    
    function drawFrame() {
      if (!selectedVideo || !videoElement.videoWidth) return;
      
      const w = previewCanvas.width;
      const h = previewCanvas.height;
      
      ctx.drawImage(videoElement, 0, 0, w, h);
      
      if (currentFilter !== 'none' && filterIntensity > 0) {
        applyFilter(currentFilter, ctx, w, h, filterIntensity);
      }
      
      drawOverlays(ctx, w, h);
    }
    
    function updateTimeDisplay() {
      const current = formatTime(videoElement.currentTime);
      const total = formatTime(videoElement.duration || 0);
      document.getElementById('timeDisplay').textContent = `${current} / ${total}`;
      
      const progress = (videoElement.currentTime / videoElement.duration) * 100 || 0;
      document.getElementById('scrubberFill').style.width = progress + '%';
    }
    
    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = Math.floor(s % 60);
      return `${m}:${sec.toString().padStart(2, '0')}`;
    }
    
    function seek(e) {
      if (!selectedVideo) return;
      const rect = e.target.getBoundingClientRect();
      const percent = (e.clientX - rect.left) / rect.width;
      videoElement.currentTime = percent * videoElement.duration;
      drawFrame();
      updateTimeDisplay();
    }
    
    function skipBackward() {
      if (!selectedVideo) return;
      videoElement.currentTime = Math.max(0, videoElement.currentTime - 5);
      drawFrame();
      updateTimeDisplay();
    }
    
    function skipForward() {
      if (!selectedVideo) return;
      videoElement.currentTime = Math.min(videoElement.duration, videoElement.currentTime + 5);
      drawFrame();
      updateTimeDisplay();
    }
    
    videoElement.onended = () => {
      isPlaying = false;
      document.getElementById('playBtn').textContent = '‚ñ∂';
    };
    
    videoElement.ontimeupdate = () => {
      if (!isPlaying) {
        drawFrame();
        updateTimeDisplay();
      }
    };
    
    // ========== FILTERS ==========
    function setFilter(name, updateVideo = true) {
      currentFilter = name;
      
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === name);
      });
      
      if (updateVideo && selectedVideo) {
        selectedVideo.filter = name;
        
      }
      
      drawFrame();
    }
    
    function updateIntensity(val) {
      filterIntensity = val / 100;
      document.getElementById('intensityValue').textContent = val + '%';
      
      if (selectedVideo) {
        selectedVideo.filterIntensity = filterIntensity;
        
      }
      
      drawFrame();
    }
    
    function applyFilter(filter, ctx, w, h, intensity) {
      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;
      
      switch(filter) {
        case 'vhs': {
          // === AUTHENTIC VHS LOOK ===
          // 1. Slight color bleed/smear
          const temp = new Uint8ClampedArray(data);
          const chromaShift = Math.round(2 * intensity);
          
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const i = (y * w + x) * 4;
              // Red channel shifts left
              const redX = Math.max(0, x - chromaShift);
              const redI = (y * w + redX) * 4;
              // Blue channel shifts right  
              const blueX = Math.min(w - 1, x + chromaShift);
              const blueI = (y * w + blueX) * 4;
              
              data[i] = temp[redI];
              data[i + 2] = temp[blueI + 2];
            }
          }
          
          // 2. Reduce saturation slightly and add warmth
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Desaturate
            const sat = 1 - (0.25 * intensity);
            data[i] = gray + (r - gray) * sat;
            data[i + 1] = gray + (g - gray) * sat;
            data[i + 2] = gray + (b - gray) * sat;
            
            // Warm tint
            data[i] = Math.min(255, data[i] + 10 * intensity);
            data[i + 1] = Math.min(255, data[i + 1] + 5 * intensity);
            data[i + 2] = Math.max(0, data[i + 2] - 8 * intensity);
            
            // Subtle noise
            const noise = (Math.random() - 0.5) * 15 * intensity;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // 3. Scan lines
          ctx.fillStyle = `rgba(0, 0, 0, ${0.1 * intensity})`;
          for (let y = 0; y < h; y += 2) {
            ctx.fillRect(0, y, w, 1);
          }
          
          // 4. Subtle vignette
          const vhsVig = ctx.createRadialGradient(w/2, h/2, h * 0.35, w/2, h/2, h * 0.85);
          vhsVig.addColorStop(0, 'rgba(0,0,0,0)');
          vhsVig.addColorStop(1, `rgba(0,0,0,${0.3 * intensity})`);
          ctx.fillStyle = vhsVig;
          ctx.fillRect(0, 0, w, h);
          break;
        }
        
        case 'super8': {
          // === SUPER 8 FILM ===
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i + 1], b = data[i + 2];
            
            // Lifted blacks, faded look
            const lift = 20 * intensity;
            r = r + lift - (r * 0.1 * intensity);
            g = g + lift - (g * 0.08 * intensity);
            b = b + lift - (b * 0.05 * intensity);
            
            // Warm orange push
            r = Math.min(255, r + 15 * intensity);
            g = Math.min(255, g + 5 * intensity);
            b = Math.max(0, b - 15 * intensity);
            
            // Slight saturation boost
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            r = gray + (r - gray) * (1 + 0.1 * intensity);
            g = gray + (g - gray) * (1 + 0.1 * intensity);
            b = gray + (b - gray) * (1 + 0.1 * intensity);
            
            // Film grain
            const grain = (Math.random() - 0.5) * 25 * intensity;
            data[i] = Math.max(0, Math.min(255, r + grain));
            data[i + 1] = Math.max(0, Math.min(255, g + grain * 0.9));
            data[i + 2] = Math.max(0, Math.min(255, b + grain * 0.8));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Strong vignette (projector look)
          const s8Vig = ctx.createRadialGradient(w/2, h/2, h * 0.2, w/2, h/2, h * 0.7);
          s8Vig.addColorStop(0, 'rgba(0,0,0,0)');
          s8Vig.addColorStop(0.6, `rgba(0,0,0,${0.1 * intensity})`);
          s8Vig.addColorStop(1, `rgba(0,0,0,${0.6 * intensity})`);
          ctx.fillStyle = s8Vig;
          ctx.fillRect(0, 0, w, h);
          break;
        }
        
        case '8mm': {
          // === 8MM FILM - Heavy vintage ===
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Strong sepia/amber
            let newR = gray + 40 * intensity;
            let newG = gray + 15 * intensity;
            let newB = gray - 20 * intensity;
            
            // Blend with original
            const blend = 0.6 * intensity;
            newR = r * (1 - blend) + newR * blend;
            newG = g * (1 - blend) + newG * blend;
            newB = b * (1 - blend) + newB * blend;
            
            // Heavy grain
            const grain = (Math.random() - 0.5) * 40 * intensity;
            data[i] = Math.max(0, Math.min(255, newR + grain));
            data[i + 1] = Math.max(0, Math.min(255, newG + grain));
            data[i + 2] = Math.max(0, Math.min(255, newB + grain * 0.7));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Heavy vignette
          const mmVig = ctx.createRadialGradient(w/2, h/2, h * 0.15, w/2, h/2, h * 0.6);
          mmVig.addColorStop(0, 'rgba(0,0,0,0)');
          mmVig.addColorStop(1, `rgba(0,0,0,${0.7 * intensity})`);
          ctx.fillStyle = mmVig;
          ctx.fillRect(0, 0, w, h);
          break;
        }
        
        case '16mm': {
          // === 16MM CINEMA FILM ===
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i + 1], b = data[i + 2];
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Teal shadows, orange highlights
            if (lum < 85) {
              // Shadows: push teal
              r = r - 8 * intensity;
              g = g + 2 * intensity;
              b = b + 12 * intensity;
            } else if (lum > 170) {
              // Highlights: push warm
              r = r + 10 * intensity;
              g = g + 3 * intensity;
              b = b - 8 * intensity;
            }
            
            // Subtle grain
            const grain = (Math.random() - 0.5) * 15 * intensity;
            data[i] = Math.max(0, Math.min(255, r + grain));
            data[i + 1] = Math.max(0, Math.min(255, g + grain));
            data[i + 2] = Math.max(0, Math.min(255, b + grain));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Gentle vignette
          const vig16 = ctx.createRadialGradient(w/2, h/2, h * 0.4, w/2, h/2, h * 0.9);
          vig16.addColorStop(0, 'rgba(0,0,0,0)');
          vig16.addColorStop(1, `rgba(0,0,0,${0.35 * intensity})`);
          ctx.fillStyle = vig16;
          ctx.fillRect(0, 0, w, h);
          break;
        }
        
        case 'cinematic': {
          // === CINEMATIC TEAL & ORANGE ===
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i + 1], b = data[i + 2];
            const lum = 0.299 * r + 0.587 * g + 0.114 * b;
            
            // Shadows: strong teal
            if (lum < 100) {
              r = Math.max(0, r - 20 * intensity);
              g = g + 5 * intensity;
              b = Math.min(255, b + 25 * intensity);
            } 
            // Highlights: warm orange
            else if (lum > 150) {
              r = Math.min(255, r + 20 * intensity);
              g = Math.min(255, g + 8 * intensity);
              b = Math.max(0, b - 20 * intensity);
            }
            // Midtones: slight desaturation
            else {
              const gray = lum;
              r = r * 0.9 + gray * 0.1;
              g = g * 0.9 + gray * 0.1;
              b = b * 0.9 + gray * 0.1;
            }
            
            // Increase contrast slightly
            r = ((r / 255 - 0.5) * (1 + 0.1 * intensity) + 0.5) * 255;
            g = ((g / 255 - 0.5) * (1 + 0.1 * intensity) + 0.5) * 255;
            b = ((b / 255 - 0.5) * (1 + 0.1 * intensity) + 0.5) * 255;
            
            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Letterbox bars
          const barH = Math.round(h * 0.12 * intensity);
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, w, barH);
          ctx.fillRect(0, h - barH, w, barH);
          break;
        }
        
        case 'noir': {
          // === FILM NOIR B&W ===
          for (let i = 0; i < data.length; i += 4) {
            let gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            
            // High contrast S-curve
            gray = gray / 255;
            gray = gray < 0.5 
              ? Math.pow(gray * 2, 1.5 + 0.5 * intensity) / 2
              : 1 - Math.pow((1 - gray) * 2, 1.5 + 0.5 * intensity) / 2;
            gray = gray * 255;
            
            // Subtle grain
            const grain = (Math.random() - 0.5) * 20 * intensity;
            const final = Math.max(0, Math.min(255, gray + grain));
            
            data[i] = final;
            data[i + 1] = final;
            data[i + 2] = final;
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Strong vignette for noir mood
          const noirVig = ctx.createRadialGradient(w/2, h/2, h * 0.2, w/2, h/2, h * 0.7);
          noirVig.addColorStop(0, 'rgba(0,0,0,0)');
          noirVig.addColorStop(1, `rgba(0,0,0,${0.55 * intensity})`);
          ctx.fillStyle = noirVig;
          ctx.fillRect(0, 0, w, h);
          break;
        }
        
        case 'betamax': {
          // === BETAMAX - Slightly cleaner than VHS ===
          const bTemp = new Uint8ClampedArray(data);
          const bShift = Math.round(1.5 * intensity);
          
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const i = (y * w + x) * 4;
              const blueX = Math.min(w - 1, x + bShift);
              const blueI = (y * w + blueX) * 4;
              data[i + 2] = bTemp[blueI + 2];
            }
          }
          
          for (let i = 0; i < data.length; i += 4) {
            // Cooler tint than VHS
            data[i + 2] = Math.min(255, data[i + 2] + 8 * intensity);
            
            // Less noise than VHS
            const noise = (Math.random() - 0.5) * 10 * intensity;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Lighter scan lines
          ctx.fillStyle = `rgba(0, 0, 0, ${0.06 * intensity})`;
          for (let y = 0; y < h; y += 2) {
            ctx.fillRect(0, y, w, 1);
          }
          break;
        }
        
        case 'surveillance': {
          // === SECURITY CAMERA ===
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i + 1], b = data[i + 2];
            const avg = (r + g + b) / 3;
            
            // Green tint, desaturated
            data[i] = avg * (0.8 - 0.2 * intensity);
            data[i + 1] = Math.min(255, avg * (1.1 + 0.15 * intensity));
            data[i + 2] = avg * (0.8 - 0.2 * intensity);
            
            // Heavy noise
            if (Math.random() < 0.3 * intensity) {
              const noise = (Math.random() - 0.5) * 50 * intensity;
              data[i] = Math.max(0, Math.min(255, data[i] + noise));
              data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
              data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
            }
          }
          
          ctx.putImageData(imageData, 0, 0);
          
          // Heavy scan lines
          ctx.fillStyle = `rgba(0, 0, 0, ${0.15 * intensity})`;
          for (let y = 0; y < h; y += 2) {
            ctx.fillRect(0, y, w, 1);
          }
          
          // Slight vignette
          const survVig = ctx.createRadialGradient(w/2, h/2, h * 0.3, w/2, h/2, h * 0.85);
          survVig.addColorStop(0, 'rgba(0,0,0,0)');
          survVig.addColorStop(1, `rgba(0,0,0,${0.4 * intensity})`);
          ctx.fillStyle = survVig;
          ctx.fillRect(0, 0, w, h);
          break;
        }
      }
    }
    
    // ========== OVERLAYS ==========
    function toggleOverlay(type) {
      const el = document.getElementById('toggle' + type.charAt(0).toUpperCase() + type.slice(1));
      
      if (type === 'timestamp') {
        showTimestamp = !showTimestamp;
        el.classList.toggle('on', showTimestamp);
      } else if (type === 'camera') {
        showCameraInfo = !showCameraInfo;
        el.classList.toggle('on', showCameraInfo);
      } else if (type === 'location') {
        showLocation = !showLocation;
        el.classList.toggle('on', showLocation);
      }
      
      drawFrame();
    }
    
    function drawOverlays(ctx, w, h) {
      if (!selectedVideo) return;
      
      const padding = Math.max(15, w * 0.02);
      const fontSize = selectedVideo.fontSize || currentFontSize || 24;
      const fontFamily = selectedVideo.fontFamily || currentFont || 'VT323';
      const textColor = selectedVideo.textColor || currentTextColor || 'auto';
      const scale = Math.min(w / 1920, h / 1080);
      const scaledFont = Math.max(fontSize, fontSize * scale);
      let yPos = h - padding;
      
      const isLight = sampleBrightness(ctx, w, h) > 0.5;
      
      // Determine text colors based on setting
      let primaryColor, accentColor1, accentColor2, timestampColor;
      if (textColor === 'auto') {
        primaryColor = isLight ? 'rgba(30,30,30,0.95)' : 'rgba(255,255,255,0.95)';
        accentColor1 = isLight ? 'rgba(0,80,150,0.95)' : 'rgba(150,220,255,0.95)';
        accentColor2 = isLight ? 'rgba(100,50,150,0.95)' : 'rgba(220,180,255,0.95)';
        timestampColor = isLight ? 'rgba(180,100,0,0.95)' : 'rgba(255,200,50,0.95)';
      } else {
        primaryColor = textColor;
        accentColor1 = textColor;
        accentColor2 = textColor;
        timestampColor = textColor;
      }
      
      const shadowColor = isLight ? 'rgba(255,255,255,0.9)' : 'rgba(0,0,0,0.9)';
      
      const drawText = (text, x, y, size, color) => {
        ctx.font = `${size}px '${fontFamily}', monospace, sans-serif`;
        ctx.textAlign = 'right';
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 4;
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.shadowColor = 'transparent';
      };
      
      if (selectedVideo.title) {
        drawText(selectedVideo.title, w - padding, yPos, scaledFont, primaryColor);
        yPos -= scaledFont * 1.3;
      }
      
      if (showLocation && selectedVideo.metadata.location) {
        drawText('üìç ' + selectedVideo.metadata.location, w - padding, yPos, scaledFont * 0.8, accentColor1);
        yPos -= scaledFont * 1.2;
      }
      
      if (showCameraInfo && selectedVideo.metadata.camera) {
        drawText('üì∑ ' + selectedVideo.metadata.camera, w - padding, yPos, scaledFont * 0.8, accentColor2);
        yPos -= scaledFont * 1.2;
      }
      
      if (showTimestamp) {
        let baseDate;
        if (selectedVideo.customDate) baseDate = new Date(selectedVideo.customDate);
        else if (selectedVideo.recordingDate) baseDate = selectedVideo.recordingDate;
        else baseDate = new Date();
        
        const displayDate = new Date(baseDate.getTime() + videoElement.currentTime * 1000);
        drawText(formatVHSDate(displayDate), w - padding, yPos, scaledFont * 0.9, timestampColor);
      }
    }
    
    function sampleBrightness(ctx, w, h) {
      try {
        const imgData = ctx.getImageData(w - 200, h - 100, 180, 80);
        let total = 0;
        for (let i = 0; i < imgData.data.length; i += 16) {
          total += 0.299 * imgData.data[i] + 0.587 * imgData.data[i + 1] + 0.114 * imgData.data[i + 2];
        }
        return total / (imgData.data.length / 16) / 255;
      } catch { return 0.3; }
    }
    
    function formatVHSDate(d) {
      const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
      const day = d.getDate();
      const month = months[d.getMonth()];
      const year = d.getFullYear();
      const hours = d.getHours();
      const mins = String(d.getMinutes()).padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const h12 = hours % 12 || 12;
      return `${month} ${day} ${year}  ${h12}:${mins} ${ampm}`;
    }
    
    function updateTitle(val) {
      if (selectedVideo) {
        selectedVideo.title = val;
        
        drawFrame();
      }
    }
    
    function updateDate(val) {
      if (selectedVideo) {
        selectedVideo.customDate = val;
        
        drawFrame();
      }
    }
    
    function updateFont(val) {
      currentFont = val;
      if (selectedVideo) {
        selectedVideo.fontFamily = val;
        
      }
      drawFrame();
    }
    
    function updateFontSize(val) {
      currentFontSize = parseInt(val);
      document.getElementById('fontSizeValue').textContent = val + 'px';
      if (selectedVideo) {
        selectedVideo.fontSize = currentFontSize;
        
      }
      drawFrame();
    }
    
    function setTextColor(color) {
      currentTextColor = color;
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === color);
      });
      if (selectedVideo) {
        selectedVideo.textColor = color;
        
      }
      drawFrame();
    }
    
    // ========== GOOGLE DRIVE ==========
    const GOOGLE_CLIENT_ID = '574709519810-u38ks2ie636hr2flri4ndusth6klgbhq.apps.googleusercontent.com';
    const SCOPES = 'https://www.googleapis.com/auth/drive.readonly';
    
    let accessToken = null;
    let tokenClient = null;
    let gisInited = false;
    
    function initGis() {
      if (typeof google !== 'undefined' && google.accounts) {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: GOOGLE_CLIENT_ID,
          scope: SCOPES,
          callback: handleAuthResponse,
        });
        gisInited = true;
      }
    }
    
    const gisCheck = setInterval(() => {
      if (typeof google !== 'undefined' && google.accounts && !gisInited) {
        initGis();
        clearInterval(gisCheck);
      }
    }, 100);
    
    function handleAuthResponse(response) {
      if (response.error) {
        console.error('Auth error:', response);
        return;
      }
      accessToken = response.access_token;
      if (pendingAction) {
        pendingAction();
        pendingAction = null;
      }
    }
    
    let pendingAction = null;
    
    async function authenticateGoogle() {
      return new Promise((resolve) => {
        if (accessToken) {
          resolve();
          return;
        }
        
        if (!gisInited) {
          alert('Google API not loaded. Please try again.');
          resolve();
          return;
        }
        
        pendingAction = resolve;
        tokenClient.requestAccessToken({ prompt: 'consent' });
      });
    }
    
    // Drive picker
    let driveFolderId = 'root';
    let drivePath = [{ id: 'root', name: 'My Drive' }];
    let driveFolders = [];
    let driveVideos = [];
    let driveSelected = new Set();
    
    async function openDrivePicker() {
      if (!accessToken) {
        await authenticateGoogle();
        if (!accessToken) return;
      }
      
      driveFolderId = 'root';
      drivePath = [{ id: 'root', name: 'My Drive' }];
      driveSelected.clear();
      
      document.getElementById('driveModal').classList.add('active');
      loadDriveContents();
    }
    
    function closeDriveModal() {
      document.getElementById('driveModal').classList.remove('active');
    }
    
    async function loadDriveContents() {
      document.getElementById('driveLoading').style.display = 'flex';
      document.getElementById('driveGrid').innerHTML = '';
      updateDriveBreadcrumb();
      
      try {
        // Load folders
        const folderUrl = `https://www.googleapis.com/drive/v3/files?q='${driveFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false&fields=files(id,name)&orderBy=name`;
        const folderRes = await fetch(folderUrl, {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });
        const folderData = await folderRes.json();
        driveFolders = folderData.files || [];
        
        // Load videos
        const videoUrl = `https://www.googleapis.com/drive/v3/files?q='${driveFolderId}' in parents and mimeType contains 'video/' and trashed=false&fields=files(id,name,mimeType,thumbnailLink,createdTime)&orderBy=createdTime desc`;
        const videoRes = await fetch(videoUrl, {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });
        const videoData = await videoRes.json();
        driveVideos = videoData.files || [];
        
        renderDriveGrid();
        
      } catch (e) {
        console.error('Drive error:', e);
        document.getElementById('driveGrid').innerHTML = '<div class="empty-state"><p>Error loading</p></div>';
      }
      
      document.getElementById('driveLoading').style.display = 'none';
    }
    
    function updateDriveBreadcrumb() {
      const el = document.getElementById('driveBreadcrumb');
      el.innerHTML = drivePath.map((f, i) => {
        const isLast = i === drivePath.length - 1;
        return `
          ${i > 0 ? '<span class="breadcrumb-sep">‚Ä∫</span>' : ''}
          <button class="breadcrumb-btn ${isLast ? 'current' : ''}" onclick="${isLast ? '' : `navigateDrive('${f.id}', ${i})`}">${f.name}</button>
        `;
      }).join('');
    }
    
    function navigateDrive(folderId, pathIndex) {
      driveFolderId = folderId;
      if (pathIndex !== undefined) {
        drivePath = drivePath.slice(0, pathIndex + 1);
      }
      loadDriveContents();
    }
    
    function openDriveFolder(folderId, folderName) {
      driveFolderId = folderId;
      drivePath.push({ id: folderId, name: folderName });
      loadDriveContents();
    }
    
    function toggleDriveVideo(id) {
      if (driveSelected.has(id)) {
        driveSelected.delete(id);
      } else {
        driveSelected.add(id);
      }
      renderDriveGrid();
    }
    
    function renderDriveGrid() {
      const grid = document.getElementById('driveGrid');
      
      const foldersHtml = driveFolders.map(f => `
        <div class="drive-folder" onclick="openDriveFolder('${f.id}', '${f.name.replace(/'/g, "\\'")}')">
          <div class="icon">üìÅ</div>
          <div class="name">${f.name}</div>
        </div>
      `).join('');
      
      const videosHtml = driveVideos.map(v => `
        <div class="drive-video ${driveSelected.has(v.id) ? 'selected' : ''}" onclick="toggleDriveVideo('${v.id}')">
          ${v.thumbnailLink ? `<img src="${v.thumbnailLink}" onerror="this.style.display='none'">` : ''}
          <div class="placeholder" ${v.thumbnailLink ? 'style="display:none"' : ''}>üé¨</div>
          <div class="check">‚úì</div>
          <div class="info">${v.name}</div>
        </div>
      `).join('');
      
      if (driveFolders.length === 0 && driveVideos.length === 0) {
        grid.innerHTML = '<div class="empty-state" style="grid-column:1/-1"><p>No items</p></div>';
      } else {
        grid.innerHTML = foldersHtml + videosHtml;
      }
      
      document.getElementById('driveImportBtn').disabled = driveSelected.size === 0;
      document.getElementById('driveImportBtn').textContent = driveSelected.size > 0 ? `Import (${driveSelected.size})` : 'Import';
    }
    
    async function importSelected() {
      const items = driveVideos.filter(v => driveSelected.has(v.id));
      if (items.length === 0) return;
      
      closeDriveModal();
      
      for (const item of items) {
        await downloadDriveVideo(item);
      }
    }
    
    async function downloadDriveVideo(item) {
      showProcessing('Downloading: ' + item.name);
      
      try {
        const res = await fetch(`https://www.googleapis.com/drive/v3/files/${item.id}?alt=media`, {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });
        
        const blob = await res.blob();
        const file = new File([blob], item.name, { type: item.mimeType });
        
        await addVideo(file, {
          recordingDate: item.createdTime ? new Date(item.createdTime) : null,
          source: 'Google Drive'
        });
        
      } catch (e) {
        console.error('Download error:', e);
        alert('Failed to download: ' + item.name);
      }
      
      hideProcessing();
    }
    
    // ========== DOWNLOAD VIDEO (MP4) ==========
    let ffmpeg = null;
    let ffmpegLoaded = false;
    let ffmpegLoading = false;
    
    async function loadFFmpeg() {
      if (ffmpegLoaded) return true;
      if (ffmpegLoading) {
        // Wait for existing load attempt
        while (ffmpegLoading) {
          await new Promise(r => setTimeout(r, 100));
        }
        return ffmpegLoaded;
      }
      
      ffmpegLoading = true;
      
      try {
        // Check if FFmpeg libraries loaded
        if (typeof FFmpegWASM === 'undefined' || typeof FFmpegUtil === 'undefined') {
          console.error('FFmpeg libraries not loaded');
          ffmpegLoading = false;
          return false;
        }
        
        const { FFmpeg } = FFmpegWASM;
        const { toBlobURL } = FFmpegUtil;
        
        ffmpeg = new FFmpeg();
        
        // Use single-threaded core (works without special headers)
        const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
        
        await ffmpeg.load({
          coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
          wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
        });
        
        ffmpegLoaded = true;
        ffmpegLoading = false;
        console.log('FFmpeg loaded successfully');
        return true;
      } catch (e) {
        console.error('FFmpeg load error:', e);
        ffmpegLoading = false;
        return false;
      }
    }
    
    async function downloadCurrentClip() {
      if (!selectedVideo) {
        alert('Select a clip first');
        return;
      }
      await renderAndDownload([selectedVideo], selectedVideo.name.replace(/\.[^.]+$/, ''));
    }
    
    async function downloadAllClips() {
      if (videos.length === 0) {
        alert('No clips to download');
        return;
      }
      
      const sorted = [...videos].sort((a, b) => 
        (a.recordingDate || a.uploadTime) - (b.recordingDate || b.uploadTime)
      );
      
      await renderAndDownload(sorted, 'home_movie_' + new Date().toISOString().split('T')[0]);
    }
    
    async function renderAndDownload(videoList, filename) {
      showProcessing('Loading MP4 encoder (first time may take a moment)...');
      document.getElementById('processingPercent').textContent = '';
      
      // Load FFmpeg first
      const ffmpegReady = await loadFFmpeg();
      if (!ffmpegReady) {
        const useWebM = confirm('MP4 encoder failed to load. Download as WebM instead?');
        if (!useWebM) {
          hideProcessing();
          return;
        }
      }
      
      document.getElementById('processingText').textContent = 'Preparing...';
      
      const canvas = document.createElement('canvas');
      const exportCtx = canvas.getContext('2d');
      
      // Set up audio context for capturing audio
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const audioDestination = audioContext.createMediaStreamDestination();
      
      // Get first video dimensions for canvas size
      const firstVideo = document.createElement('video');
      await new Promise(resolve => {
        firstVideo.src = videoList[0].url;
        firstVideo.onloadedmetadata = () => {
          canvas.width = firstVideo.videoWidth;
          canvas.height = firstVideo.videoHeight;
          firstVideo.src = '';
          resolve();
        };
      });
      
      try {
        // Combine video and audio streams
        const videoStream = canvas.captureStream(30);
        const combinedStream = new MediaStream([
          ...videoStream.getVideoTracks(),
          ...audioDestination.stream.getAudioTracks()
        ]);
        
        // Use WebM for recording (best browser support)
        let mimeType = 'video/webm;codecs=vp9';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'video/webm;codecs=vp8';
        }
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'video/webm';
        }
        
        const recorder = new MediaRecorder(combinedStream, {
          mimeType,
          videoBitsPerSecond: 12000000 // 12 Mbps for high quality
        });
        
        const chunks = [];
        recorder.ondataavailable = e => {
          if (e.data.size > 0) chunks.push(e.data);
        };
        
        // Calculate total duration
        let totalDuration = 0;
        const durations = [];
        for (const v of videoList) {
          const dur = await getVideoDuration(v.url);
          durations.push(dur);
          totalDuration += dur;
        }
        
        let processedTime = 0;
        recorder.start(100);
        
        // Process each video
        for (let i = 0; i < videoList.length; i++) {
          const v = videoList[i];
          const duration = durations[i];
          
          document.getElementById('processingText').textContent = `Rendering: ${v.name}`;
          
          // Create new video element for each clip to avoid audio source reuse issues
          const clipVideo = document.createElement('video');
          clipVideo.muted = true;
          clipVideo.playsInline = true;
          
          await new Promise((resolve) => {
            clipVideo.src = v.url;
            
            clipVideo.onloadeddata = async () => {
              // Update canvas size if video dimensions differ
              if (clipVideo.videoWidth !== canvas.width || clipVideo.videoHeight !== canvas.height) {
                canvas.width = clipVideo.videoWidth;
                canvas.height = clipVideo.videoHeight;
              }
              
              // Connect video audio to output
              let audioSource = null;
              try {
                audioSource = audioContext.createMediaElementSource(clipVideo);
                audioSource.connect(audioDestination);
              } catch (e) {
                console.log('Audio connection note:', e.message);
              }
              
              clipVideo.currentTime = 0;
              await clipVideo.play();
              
              const startTime = processedTime;
              
              const renderLoop = () => {
                if (clipVideo.paused || clipVideo.ended) {
                  processedTime = startTime + duration;
                  // Disconnect and clean up
                  clipVideo.pause();
                  clipVideo.src = '';
                  resolve();
                  return;
                }
                
                // Draw video frame
                exportCtx.drawImage(clipVideo, 0, 0, canvas.width, canvas.height);
                
                // Apply filter
                if (v.filter && v.filter !== 'none') {
                  applyFilter(v.filter, exportCtx, canvas.width, canvas.height, v.filterIntensity || 0.7);
                }
                
                // Draw overlays
                drawExportOverlays(exportCtx, canvas.width, canvas.height, v, clipVideo.currentTime);
                
                // Update progress (rendering is 0-50%)
                const progress = ((startTime + clipVideo.currentTime) / totalDuration) * 50;
                document.getElementById('processingPercent').textContent = Math.round(progress) + '%';
                
                requestAnimationFrame(renderLoop);
              };
              
              renderLoop();
            };
            
            clipVideo.onended = () => resolve();
            clipVideo.onerror = () => resolve();
          });
        }
        
        // Stop recording
        recorder.stop();
        
        // Wait for WebM data
        const webmBlob = await new Promise(resolve => {
          recorder.onstop = () => {
            resolve(new Blob(chunks, { type: mimeType }));
          };
        });
        
        // Convert to MP4 if FFmpeg is loaded
        if (ffmpegReady && ffmpeg) {
          document.getElementById('processingText').textContent = 'Converting to MP4...';
          document.getElementById('processingPercent').textContent = '50%';
          
          try {
            const { fetchFile } = FFmpegUtil;
            
            // Write WebM to FFmpeg filesystem
            const webmData = await fetchFile(webmBlob);
            await ffmpeg.writeFile('input.webm', webmData);
            
            // Convert to MP4 with progress
            ffmpeg.on('progress', ({ progress }) => {
              const percent = 50 + Math.round(progress * 50);
              document.getElementById('processingPercent').textContent = percent + '%';
            });
            
            // Run FFmpeg conversion (with audio)
            await ffmpeg.exec([
              '-i', 'input.webm',
              '-c:v', 'libx264',
              '-preset', 'fast',
              '-crf', '18',
              '-c:a', 'aac',
              '-b:a', '192k',
              '-pix_fmt', 'yuv420p',
              '-movflags', '+faststart',
              'output.mp4'
            ]);
            
            // Read MP4 output
            const mp4Data = await ffmpeg.readFile('output.mp4');
            const mp4Blob = new Blob([mp4Data.buffer], { type: 'video/mp4' });
            
            // Clean up FFmpeg filesystem
            await ffmpeg.deleteFile('input.webm');
            await ffmpeg.deleteFile('output.mp4');
            
            // Download MP4
            downloadBlob(mp4Blob, filename + '.mp4');
            
          } catch (conversionError) {
            console.error('MP4 conversion failed:', conversionError);
            // Fallback to WebM
            downloadBlob(webmBlob, filename + '.webm');
            alert('MP4 conversion failed. Downloaded as WebM instead.');
          }
        } else {
          // Download WebM if FFmpeg not available
          downloadBlob(webmBlob, filename + '.webm');
        }
        
        document.getElementById('processingText').textContent = 'Complete!';
        document.getElementById('processingPercent').textContent = '100%';
        await new Promise(r => setTimeout(r, 500));
        
        // Clean up audio context
        audioContext.close();
        
      } catch (e) {
        console.error('Export error:', e);
        alert('Download failed: ' + e.message);
        audioContext.close();
      }
      
      hideProcessing();
    }
    
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
    
    function getVideoDuration(url) {
      return new Promise(resolve => {
        const v = document.createElement('video');
        v.src = url;
        v.onloadedmetadata = () => resolve(v.duration || 5);
        v.onerror = () => resolve(5);
      });
    }
    
    function drawExportOverlays(ctx, w, h, video, currentTime) {
      const padding = Math.max(15, w * 0.02);
      const fontSize = video.fontSize || 24;
      const fontFamily = video.fontFamily || 'VT323';
      const textColor = video.textColor || 'auto';
      const scale = Math.min(w / 1920, h / 1080);
      const scaledFont = Math.max(fontSize, fontSize * scale);
      let yPos = h - padding;
      
      const isLight = false; // Assume dark for export
      
      let primaryColor, accentColor1, accentColor2, timestampColor;
      if (textColor === 'auto') {
        primaryColor = 'rgba(255,255,255,0.95)';
        accentColor1 = 'rgba(150,220,255,0.95)';
        accentColor2 = 'rgba(220,180,255,0.95)';
        timestampColor = 'rgba(255,200,50,0.95)';
      } else {
        primaryColor = textColor;
        accentColor1 = textColor;
        accentColor2 = textColor;
        timestampColor = textColor;
      }
      
      const drawText = (text, x, y, size, color) => {
        ctx.font = `${size}px '${fontFamily}', monospace, sans-serif`;
        ctx.textAlign = 'right';
        ctx.shadowColor = 'rgba(0,0,0,0.9)';
        ctx.shadowBlur = 4;
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.shadowColor = 'transparent';
      };
      
      if (video.title) {
        drawText(video.title, w - padding, yPos, scaledFont, primaryColor);
        yPos -= scaledFont * 1.3;
      }
      
      if (showLocation && video.metadata?.location) {
        drawText('üìç ' + video.metadata.location, w - padding, yPos, scaledFont * 0.8, accentColor1);
        yPos -= scaledFont * 1.2;
      }
      
      if (showCameraInfo && video.metadata?.camera) {
        drawText('üì∑ ' + video.metadata.camera, w - padding, yPos, scaledFont * 0.8, accentColor2);
        yPos -= scaledFont * 1.2;
      }
      
      if (showTimestamp) {
        let baseDate;
        if (video.customDate) baseDate = new Date(video.customDate);
        else if (video.recordingDate) baseDate = video.recordingDate;
        else baseDate = new Date();
        
        const displayDate = new Date(baseDate.getTime() + currentTime * 1000);
        drawText(formatVHSDate(displayDate), w - padding, yPos, scaledFont * 0.9, timestampColor);
      }
    }
    
    // ========== METADATA ==========
    async function extractVideoMetadata(file) {
      const meta = { creationDate: null, camera: '', location: '', gps: null };
      
      try {
        const buffer = await file.arrayBuffer();
        const dv = new DataView(buffer);
        
        const getStr = (o, len) => {
          let s = '';
          for (let i = 0; i < len && o + i < buffer.byteLength; i++) {
            s += String.fromCharCode(dv.getUint8(o + i));
          }
          return s;
        };
        
        let offset = 0;
        while (offset < buffer.byteLength - 8) {
          const size = dv.getUint32(offset);
          const type = getStr(offset + 4, 4);
          
          if (size < 8 || size > buffer.byteLength - offset) break;
          
          if (type === 'mvhd') {
            const ver = dv.getUint8(offset + 8);
            let ct = ver === 1 ? Number(dv.getBigUint64(offset + 12)) : dv.getUint32(offset + 12);
            if (ct > 0) {
              const d = new Date((ct - 2082844800) * 1000);
              if (d.getFullYear() >= 1990 && d.getFullYear() <= 2100) {
                meta.creationDate = d;
              }
            }
          }
          
          offset += size;
        }
      } catch (e) {
        console.log('Metadata extraction failed:', e);
      }
      
      if (!meta.creationDate && file.lastModified) {
        meta.creationDate = new Date(file.lastModified);
      }
      
      return meta;
    }
    
    // ========== UI HELPERS ==========
    function showProcessing(text) {
      document.getElementById('processingText').textContent = text || 'Processing...';
      document.getElementById('processingPercent').textContent = '';
      document.getElementById('processing').classList.add('active');
    }
    
    function hideProcessing() {
      document.getElementById('processing').classList.remove('active');
    }
    
    function showMobilePanel(panel) {
      document.querySelectorAll('.mobile-tab').forEach((t, i) => {
        t.classList.toggle('active', (i === 0 && panel === 'left') || (i === 1 && panel === 'center') || (i === 2 && panel === 'right'));
      });
      
      document.getElementById('panelLeft').classList.toggle('mobile-show', panel === 'left');
      document.getElementById('panelCenter').style.display = panel === 'center' ? 'flex' : (window.innerWidth > 768 ? 'flex' : 'none');
      document.getElementById('panelRight').classList.toggle('mobile-show', panel === 'right');
    }
    
    // Init
    setTimeout(initGis, 500);
  </script>
</body>
</html>
